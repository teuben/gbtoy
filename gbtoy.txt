GBTOY is a toy model for GBTIDL.

In this version we use pyspeckit (+astropy) behind the scenes, since
it knows how to handle SDFITS files. This means only nodding reduction
is supported, no frequency switching yet. (not sure about position
switching)

nodding:    a mirror like device make it look at a different "blank" sky
            nodding secondary. or are there other nodding options?
position:   telescope physically looks at a different "blank" sky?
frequency:  use a nearby part of spectrum to be able to baseline subtract



The goal in this "toy" version is to explore how a pythonic GBTIDL would
look and feel and get user feedback before we continue.

GBTOY could become GBTPY if we're doing it more pythonic, and not
letting it mirror GBTIDL as much as GBTOY does. One way is to
mirror/use/extend the pyspeckit approach. Plenty of examples of those
exist, but for GBT only 2 examples are given in pyspeckit-tests, and
only 3C286 sort of works now, while jd_test with
AGBT11B_029_01.raw.acs.fits currently lacks the data.

Another idea could be to model the interface after CASA, with it's
global namespace, the "tget", "inp", "go" commands, etc.

This means we now have 3 possible ways to explore "GBTPY".




The first command GBTIDL users learn about is "filein"

In python a global function such as "filein" is not a good idea,
because it's easy to imagine that this function name will be a python
builtin command, or come from another package (although packages
should not import into global namespace)

So the typical way in python would be something like

   import gbtidl as g

after which you could have

   g.filein()

In my current toy model I actually do this instead:

   import gbtidl

   g = gbtidl.GBTIDL(ndc=32)

where I've created a "g" object with 32 DC's instead of the default 16.

You would then have access to these DC's as
   g.s[0]  (the PDC)
and
   g.c[0]
   
all the way to

   g.s[31]

if you want to know what 'ndc' was used,

   print("# DC's = %d" % len(g.s))

This way you can also see how to use multiple g's

   g1 = gbtidl.GBTIDL(ndc=10)
   g2 = gbtidl.GBTIDL()

and have memory optimized parallel sessions.

This suggests we should create a dictionary of IDL->PY users:

GBTIDL        ->   GBTOY

  !gc.xxx     ->   g.gc.xxx
  !g.s[0]     ->   g.s[0]
  filein, "a"      g.filein("a")

As a first example, the "quick example" from the Users' Guide would
read as follows in GBTOY:

import gbtidl           # these two commands can be pre-loaded
g = gbtidl.GBTIDL()     # with a special profile option to ipython

g.filein()              # Specify an input file using the file selection GUI
g.summary()             # Give a summary of the scans in the opened data file
g.getfs(9)
g.setregion()
g.nfit(2)
g.baseline()
g.fitgauss()
g.stats()
g.print_ps()
g.fileout('mydata.fits')
g.keep()
g.exit()


In ipython one can make profiles, such that e.g. the command "gbtidl" would launch ipython with
the gbtdil profile, which essentially executes the first two commands, readying the ipython
session 

    alias gbtidl='ipython --profile=gbtidl'

Taking the 3 examples from the Users' Guide as listed in Appendix F,
they would read as follows:

Example 1:   Position Switching
-------------------------------

g.filein('ngc5291.fits')
g.summary()

for i=g.range(51,57,2):
    g.getps(i, plnum=0)
    g.accum()
for i=g.range(51,57,2):
    g.getps(i, plnum=1)
    g.accum()
g.ave()

g.chan()
g.nregion,[3300,14800,17900,31000])
g.nfit(3)
g.sety(0.2, 0.5)
g.bshape()
g.baseline()
g.unzoom()

g.hanning(decimate=True)
g.bdrop(2500)
g.edrop(2500)
g.velo()
g.stats(2000, 3000)
g.stats(3900, 4800)
g.boxcar(8)


Example 2:
----------

Example 3: Nodding 
------------------

g.filein('I1481.fits')
g.getnod(182, plnum=0)
g.accum()
g.getnod(182, plnum=1)
g.accum()
g.getnod(184, plnum=0)
g.accum()
g.getnod(184, plnum=1)
g.accum()

g.ave()
g.setregion()
g.nfit(3)
g.baseline()

or the alternative:

g.filein('IC1481.fits')
g.summary()


g.emptystack()
g.sclear()
g.addstack(182, 188, 2)
g.tellstack()



g.freeze()
for i in range(g.acount):
  getnod( g.astack(i), plnum=0, units='Jy', tsys=60
  g.accum()
  g.copy(0, i*2+2)
  g.getnod( g.astack(i), plnum=1, units='Jy', tsys=60)
  g.accum()
  g.copy(0, i*2+3)
g.unfreeze()
g.ave()


g.setregion()
g.nfit(3)
g.bshape()
g.baseline()

g.hanning(decimate=False)
g.fileout('saved.fits')
g.keep()

g.copy(2, 0)
g.baseline()
g.show()
g.copy(0, 2)
g.freeze()
for i=g.range(3,9):
  g.copy(i, 0)
  g.baseline()
  g.bias( float(i-2)*0.2)
  g.copy(0, i)
g.show(2)
g.unfreeze()
for i=g.range(3,9):
  g.oshow(i, color='red')


# example from manual how IDL and OY compare
def myscale(g, factor=1.0):
    """
    pro myscale,factor
      tmp_data = getdata()
      tmp_data = tmp_data * factor
      setdata, tmp_data
      if !g.frozen eq 0 then show
    end
    """
    g.setdata(factor * g.getdata())
    # if !g.frozen eq 0 then show


